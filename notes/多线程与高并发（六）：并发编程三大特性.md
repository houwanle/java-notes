## 多线程与高并发（六）：并发编程三大特性

- 可见性（visibility）
- 有序性（ordering）
- 原子性（atomicity）

### 1.可见性

  ![多线程与高并发（六）：可见性_1.png](./pics/多线程与高并发（六）：可见性_1.png)

- 每个线程在运行的时候，都会把数据从内存中读出一份放在线程本地（线程缓存，不是Threadlocal），以后每次循环读取的值不是去主内存读，而是读取自己本地的缓存，不会主动去主内存里面主动读取；
- 默认情况下，一个线程改了某个值，另一个线程是看不见被改的值；
- volatile：
  - 保持线程的可见性（volatile修饰的内存，每次都会去主内存里面读一遍，对于它的任何的修改，其他线程立马可见）；
  - 保持可见性不一定要使用volatile；

  ```java
  package com.lele.c_001_00_Visibility;

  import com.lele.util.SleepHelper;

  /**
   * @author: lele
   * @date: 2021/11/25 21:57
   * @description:
   */
  public class T01_HelloVolatile {

      // 用volatile修饰，running值被改动时，其他线程也可见（volatile的保持线程的可见性）
      private static volatile boolean running = true;  // 主内存中；
      private static void m() {
          System.out.println("m start");
          while (running) {
  //            System.out.println("hello");  // 触发了可见性
          }
          System.out.println("m end!");
      }

      public static void main(String[] args) {

          new Thread(T01_HelloVolatile::m, "t1").start();

          SleepHelper.sleepSeconds(1);

          running = false;

      }
  }
  ```

  - volatile 引用类型（包括数组）只能保证引用本身的可见性，不能保证内部字段的可见性

  ```java
  package com.lele.c_001_00_Visibility;

  import com.lele.util.SleepHelper;

  /**
   * @author: lele
   * @date: 2021/11/28 21:31
   * @description: volatile 引用类型（包括数组）只能保证引用本身的可见性，不能保证内部字段的可见性
   */
  public class T02_VolatileReference {

      private static class A {
          boolean running = true;
          void m() {
              System.out.println("m start");
              while (running) {

              }
              System.out.println("m end");
          }
      }

      private volatile static A a = new A();

      public static void main(String[] args) {
          new Thread(a::m, "t1").start();
          SleepHelper.sleepSeconds(1);
          a.running = false;
      }
  }
  ```

**三级缓存**

  ![多线程与高并发（六）：三级缓存.png](./pics/多线程与高并发（六）：三级缓存.png)

  ![多线程与高并发（六）：多核CPU.png](./pics/多线程与高并发（六）：多核CPU.png)

  Registers(寄存器中)取数顺序：L1、L2、L3、内存
