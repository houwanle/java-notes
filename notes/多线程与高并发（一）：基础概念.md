## 多线程与高并发（一）：基础概念

### 1. 线程基本内容
#### 1.1 程序、进程与线程
- 程序：Program，是一个指令的集合；
- 进程：Process，（正在执行中的程序）是一个静态的概念；
  - 进程是程序的一次静态执行过程，占用特定的地址空间；
  - 每个进程都是独立的，由3部分组成：cpu、data、code；
  - 缺点：内存的浪费、CPU的负担；
- 线程：是进程中一个“单一的连续控制流程”（a single sThread, equential flow of control）/执行路径
  - 线程又被称为轻量级进程（lightweight process）
  - Threads run at the same time, independently of one another
  - 一个进程可拥有多个并行的（concurrent）线程；
  - 一个进程中的线程共享相同的内存单元/内存地址空间 -> 可以访问相同的变量和对象，而且它们从同一堆中分配对象 -> 通信、数据交换、同步操作；
  - 由于线程间的通信是在同一地址空间上进行的，所以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快；

  ![多线程与高并发（一）：进程与线程](./pics/多线程与高并发（一）：进程与线程.png)

**Javac与Java**
- Java虚拟机启动的时候会有一个进程java.exe，该进程中至少有一个线程，在负责java程序的执行。而这个线程运行的代码存在于main方法中，该线程称之为主线程。
- 一个线程的线程共享代码和数据空间；
- 线程结束，进程未必结束，但进程结束，线程一定结束；
- 进程中包含线程，线程是进程的一部分；

**线程与进程的区别**

区别 | 进程 | 线程
---|---|---
根本区别 | 作为资源分配的单位 | 调度和执行的单位
开销 | 每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销； | 线程可以看成是轻量级的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器（PC），线程切换的开销小。
所处环境 | 在操作系统中能同时运行多个任务（程序） | 在同一应用程序中有多个顺序流同时执行
分配内存 | 系统在运行的时候会为每个进程分配不同的内存区域 | 除了CPU之外，不会为线程分配内存（线程所使用的资源是他所属的进程的资源），线程组只能共享资源。
包含关系 | 没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的。 | 线程是进程的一部分，所以线程有的时候被称为是轻权进程或者轻量级进程

#### 1.2 线程的创建和启动

**Java中实现多线程（一）**
- 在Java中负责线程的这个功能的是Java.lang.Thread这个类；
- 可以通过创建Thread的实例来创建新的线程；
- 每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体；
- 通过调用Thread类的start()方法来启动一个线程；


**创建线程的方式**
- 继承Thread类
  - 步骤：
    - 继承Thread类、重写run方法、创建对象，调用start()方法启用线程；

      ```java
      package com.lele.multithread;

      /**
       * @author: lele
       * @date: 2021/6/23 6:49
       * @description:
       *
       * 实现多线程的时候：
       *      1.需要继承Thread类；
       *      2.必须重写run方法，指的是核心执行的逻辑；
       *      3.线程在启动的时候不要直接调用run方法，而是要通过start()方法来进行调用；
       *      4.每次运行相同的代码，出来的结果可能不一样，原因在于多线程谁先抢占资源，无法进行认为控制；
       */
      public class ThreadDemo01 extends Thread {
          public static void main(String[] args) {
              // 创建对象，就创建好一个线程
              ThreadDemo01 d = new ThreadDemo01();
              //启动线程使用start方法
              d.start();
              for (int i = 0; i < 5; i++) {
                  System.out.println(Thread.currentThread().getName()+"==========="+i);
              }
          }

          public void run() {
              for (int i = 0; i < 10; i++) {
                  System.out.println(Thread.currentThread().getName()+"--------"+i);
              }
          }
      }
      ```

- 实现Runnable接口
  - 步骤：
    - 实现Runnable接口、重写run方法、创建对象，调用start()方法；

    ```java
    package com.lele.multithread;

    /**
     * @author: lele
     * @date: 2021/6/23 7:17
     * @description:
     *
     * 第二种实现方式：使用了代理设计模式
     *      1.实现Runnable接口
     *      2.重写run方法
     *      3.创建Thread对象，将刚刚创建好的runnable的子类实现作为thread的构造参数；
     *      4.通过thread.start()进行启动；
     * 推荐使用第二种方式：
            1.java是单继承，将继承关系留给最需要的类
            2.使用Runnable接口之后不需要给共享变量添加static关键字，每次创建一个对象，作为共享对象即可；
     */
    public class RunnableDemo01 implements Runnable {

        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                System.out.println(Thread.currentThread().getName()+"---------"+i);
            }
        }

        public static void main(String[] args) {

            RunnableDemo01 runnableDemo01 = new RunnableDemo01();
            Thread thread = new Thread(runnableDemo01);
            thread.start();

            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName()+"=========="+i);
            }

        }
    }

    ```

**Java中实现多线程（二）**
- 继承Thread类的方式的缺点：如果我们的类已经从一个类继承（如小程序必须继承自Applet类），则无法再继承Thread类；
- 通过Runnable接口实现多线程的优点：
  - 可以同时实现继承。实现Runnable接口方式要通用一些；
  - 避免单继承
  - 方便共享资源 同一份资源 多个代理访问

**线程的代理设计模式**

![多线程与高并发：线程的代理设计模式](./pics/多线程与高并发：线程的代理设计模式.png)

- 案例

  ```java
  package com.lele.proxy;

  /**
   * @author: lele
   * @date: 2021/6/28 6:56
   * @description:
   */
  public interface KindWomen {

      // 抛媚眼
      public void makeEyesWithMen();

      public void playWithMen();
  }
  ```

  ```java
  package com.lele.proxy;

  /**
   * @author: lele
   * @date: 2021/6/28 6:57
   * @description: 代理人
   */
  public class WangPo implements KindWomen {

      private KindWomen kindWomen;

      public WangPo() {
          this.kindWomen = new PanJinLian();
      }

      public WangPo(KindWomen kindWomen) {
          this.kindWomen = kindWomen;
      }

      @Override
      public void makeEyesWithMen() {
          this.kindWomen.makeEyesWithMen();
      }

      @Override
      public void playWithMen() {
          this.kindWomen.playWithMen();
      }
  }

  ```

  ```java
  package com.lele.proxy;

  import java.nio.file.WatchEvent;

  /**
   * @author: lele
   * @date: 2021/6/28 7:01
   * @description: 被代理人
   */
  public class PanJinLian implements KindWomen {

      @Override
      public void makeEyesWithMen() {
          System.out.println("潘金莲在抛媚眼");
      }

      @Override
      public void playWithMen() {
          System.out.println("潘金莲。。。");
      }
  }
  ```

  ```java
  package com.lele.proxy;

  /**
   * @author: lele
   * @date: 2021/6/28 7:06
   * @description:
   */
  public class JiaShi implements KindWomen {

      @Override
      public void makeEyesWithMen() {
          System.out.println("贾氏在抛媚眼");
      }

      @Override
      public void playWithMen() {
          System.out.println("贾氏。。。");
      }
  }
  ```

  ```java
  package com.lele.proxy;

  /**
   * @author: lele
   * @date: 2021/6/28 7:03
   * @description:
   */
  public class XiMenQing {

      public static void main(String[] args) {

  //        WangPo wangPo = new WangPo();
  //        wangPo.playWithMen();
  //        wangPo.makeEyesWithMen();

          JiaShi jiashi = new JiaShi();
          WangPo wangPo = new WangPo(jiashi);
          wangPo.makeEyesWithMen();
          wangPo.playWithMen();
      }
  }
  ```


#### 1.3 线程的生命周期


### 2. 线程同步
#### 2.1 线程同步的必要性

#### 2.2 线程同步的实现

#### 2.3 死锁


### 3. 线程间的通信
#### 3.1 线程间通信的必要性

#### 3.2 线程通信的实现

### 4. 线程池


## JUC同步工具


## 同步容器

## 线程池

## 高频面试加分项

## Disruptor
