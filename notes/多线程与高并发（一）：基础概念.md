## 多线程与高并发（一）：基础概念

### 1. 线程基本内容
#### 1.1 程序、进程与线程
- 程序：Program，是一个指令的集合；
- 进程：Process，（正在执行中的程序）是一个静态的概念；
  - 进程是程序的一次静态执行过程，占用特定的地址空间；
  - 每个进程都是独立的，由3部分组成：cpu、data、code；
  - 缺点：内存的浪费、CPU的负担；
- 线程：是进程中一个“单一的连续控制流程”（a single sThread, equential flow of control）/执行路径
  - 线程又被称为轻量级进程（lightweight process）
  - Threads run at the same time, independently of one another
  - 一个进程可拥有多个并行的（concurrent）线程；
  - 一个进程中的线程共享相同的内存单元/内存地址空间 -> 可以访问相同的变量和对象，而且它们从同一堆中分配对象 -> 通信、数据交换、同步操作；
  - 由于线程间的通信是在同一地址空间上进行的，所以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快；

  ![多线程与高并发（一）：进程与线程](./pics/多线程与高并发（一）：进程与线程.png)

**Javac与Java**
- Java虚拟机启动的时候会有一个进程java.exe，该进程中至少有一个线程，在负责java程序的执行。而这个线程运行的代码存在于main方法中，该线程称之为主线程。
- 一个线程的线程共享代码和数据空间；
- 线程结束，进程未必结束，但进程结束，线程一定结束；
- 进程中包含线程，线程是进程的一部分；

**线程与进程的区别**

区别 | 进程 | 线程
---|---|---
根本区别 | 作为资源分配的单位 | 调度和执行的单位
开销 | 每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销； | 线程可以看成是轻量级的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器（PC），线程切换的开销小。
所处环境 | 在操作系统中能同时运行多个任务（程序） | 在同一应用程序中有多个顺序流同时执行
分配内存 | 系统在运行的时候会为每个进程分配不同的内存区域 | 除了CPU之外，不会为线程分配内存（线程所使用的资源是他所属的进程的资源），线程组只能共享资源。
包含关系 | 没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的。 | 线程是进程的一部分，所以线程有的时候被称为是轻权进程或者轻量级进程

#### 1.2 线程的创建和启动

**Java中实现多线程（一）**
- 在Java中负责线程的这个功能的是Java.lang.Thread这个类；
- 可以通过创建Thread的实例来创建新的线程；
- 每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体；
- 通过调用Thread类的start()方法来启动一个线程；


**创建线程的方式**
- 继承Thread类
  - 步骤：
    - 继承Thread类、重写run方法、创建对象，调用start()方法启用线程；

      ```java
      package com.lele.multithread;

      /**
       * @author: lele
       * @date: 2021/6/23 6:49
       * @description:
       *
       * 实现多线程的时候：
       *      1.需要继承Thread类；
       *      2.必须重写run方法，指的是核心执行的逻辑；
       *      3.线程在启动的时候不要直接调用run方法，而是要通过start()方法来进行调用；
       *      4.每次运行相同的代码，出来的结果可能不一样，原因在于多线程谁先抢占资源，无法进行认为控制；
       */
      public class ThreadDemo01 extends Thread {
          public static void main(String[] args) {
              // 创建对象，就创建好一个线程
              ThreadDemo01 d = new ThreadDemo01();
              //启动线程使用start方法
              d.start();
              for (int i = 0; i < 5; i++) {
                  System.out.println(Thread.currentThread().getName()+"==========="+i);
              }
          }

          public void run() {
              for (int i = 0; i < 10; i++) {
                  System.out.println(Thread.currentThread().getName()+"--------"+i);
              }
          }
      }
      ```

- 实现Runnable接口
  - 步骤：
    - 实现Runnable接口、重写run方法、创建对象，调用start()方法；

    ```java
    package com.lele.multithread;

    /**
     * @author: lele
     * @date: 2021/6/23 7:17
     * @description:
     *
     * 第二种实现方式：使用了代理设计模式
     *      1.实现Runnable接口
     *      2.重写run方法
     *      3.创建Thread对象，将刚刚创建好的runnable的子类实现作为thread的构造参数；
     *      4.通过thread.start()进行启动；
     * 推荐使用第二种方式：
            1.java是单继承，将继承关系留给最需要的类
            2.使用Runnable接口之后不需要给共享变量添加static关键字，每次创建一个对象，作为共享对象即可；
     */
    public class RunnableDemo01 implements Runnable {

        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                System.out.println(Thread.currentThread().getName()+"---------"+i);
            }
        }

        public static void main(String[] args) {

            RunnableDemo01 runnableDemo01 = new RunnableDemo01();
            Thread thread = new Thread(runnableDemo01);
            thread.start();

            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName()+"=========="+i);
            }

        }
    }

    ```

**Java中实现多线程（二）**
- 继承Thread类的方式的缺点：如果我们的类已经从一个类继承（如小程序必须继承自Applet类），则无法再继承Thread类；
- 通过Runnable接口实现多线程的优点：
  - 可以同时实现继承。实现Runnable接口方式要通用一些；
  - 避免单继承
  - 方便共享资源 同一份资源 多个代理访问

**线程的代理设计模式**

![多线程与高并发：线程的代理设计模式](./pics/多线程与高并发：线程的代理设计模式.png)

- 案例

  ```java
  package com.lele.proxy;

  /**
   * @author: lele
   * @date: 2021/6/28 6:56
   * @description:
   */
  public interface KindWomen {

      // 抛媚眼
      public void makeEyesWithMen();

      public void playWithMen();
  }
  ```

  ```java
  package com.lele.proxy;

  /**
   * @author: lele
   * @date: 2021/6/28 6:57
   * @description: 代理人
   */
  public class WangPo implements KindWomen {

      private KindWomen kindWomen;

      public WangPo() {
          this.kindWomen = new PanJinLian();
      }

      public WangPo(KindWomen kindWomen) {
          this.kindWomen = kindWomen;
      }

      @Override
      public void makeEyesWithMen() {
          this.kindWomen.makeEyesWithMen();
      }

      @Override
      public void playWithMen() {
          this.kindWomen.playWithMen();
      }
  }

  ```

  ```java
  package com.lele.proxy;

  import java.nio.file.WatchEvent;

  /**
   * @author: lele
   * @date: 2021/6/28 7:01
   * @description: 被代理人
   */
  public class PanJinLian implements KindWomen {

      @Override
      public void makeEyesWithMen() {
          System.out.println("潘金莲在抛媚眼");
      }

      @Override
      public void playWithMen() {
          System.out.println("潘金莲。。。");
      }
  }
  ```

  ```java
  package com.lele.proxy;

  /**
   * @author: lele
   * @date: 2021/6/28 7:06
   * @description:
   */
  public class JiaShi implements KindWomen {

      @Override
      public void makeEyesWithMen() {
          System.out.println("贾氏在抛媚眼");
      }

      @Override
      public void playWithMen() {
          System.out.println("贾氏。。。");
      }
  }
  ```

  ```java
  package com.lele.proxy;

  /**
   * @author: lele
   * @date: 2021/6/28 7:03
   * @description:
   */
  public class XiMenQing {

      public static void main(String[] args) {

  //        WangPo wangPo = new WangPo();
  //        wangPo.playWithMen();
  //        wangPo.makeEyesWithMen();

          JiaShi jiashi = new JiaShi();
          WangPo wangPo = new WangPo(jiashi);
          wangPo.makeEyesWithMen();
          wangPo.playWithMen();
      }
  }
  ```


#### 1.3 线程的生命周期

**线程状态**
- 创建（新生状态）：当创建好当前线程对象之后，没有启动之前（调用start方法之前）；
  - 用new关键字建立一个线程后，该线程对象就处于新生状态；
  - 处于新生状态的线程有自己的内存空间，通过调用start()方法进入就绪状态；
- 就绪状态：准备开始执行，并没有执行，表示调用start方法之后；
  - 当对应的线程创建完成且调用start方法之后，所有线程会添加到一个就绪队列中，所有的线程同时去抢占CPU的资源；
  - 处于就绪状态的线程具备了运行条件，但还没分配到CPU，处于线程就绪队列，等待系统为其分配CPU；
  - 当系统选定一个等待执行的线程后，它就会从就绪状态进入执行状态，该动作称为“CPU调度”。
- 运行状态：当当前进程获取到cpu资源之后，就绪队列中的所有线程会去抢占cpu的资源，谁先抢占到谁先执行，在执行的过程中就叫做运行状态；
  - 抢占到cpu资源，执行代码逻辑开始；
  - 在运行状态的线程执行自己的run方法中代码，直到 等待某资源而阻塞 或 完成任何而死亡；
  - 如果在给定的时间片内没有执行结束，就会被系统给换下来回到等待执行状态；
- 阻塞状态：在程序运行过程中，发生某些异常情况，导致当前线程无法再顺利执行下去，此时会进入阻塞状态，进入阻塞状态的原因消除之后，所有的阻塞队列会再次进入到就绪状态中，随机抢占cpu的资源，等待执行；
  - 处于运行状态的线程在某些情况下，如执行了sleep方法，或等待I/O设备等资源，将让出CPU并暂时停止自己运行，进入阻塞状态。
  - 在阻塞状态的线程不能进入就绪队列，只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续执行。
- 死亡状态：当运行中的线程正常执行完所有的代码逻辑或者因为异常情况导致程序结束叫做死亡状态；
  - 死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有三个，一个是正常运行的线程完成了它的全部工作；另外一个是线程被强制性停止，如通过stop方法来终止一个线程【不推荐使用】；三是线程抛出来未捕获的异常。

![多线程与高并发：线程状态.png](./pics/多线程与高并发：线程状态.png)

**线程操作的相关方法**

序号 | 方法名称 | 描述
---|---|---
1 | public static Thread currentThread() | 返回目前正在执行的线程
2 | public final String getName() | 返回线程的名称
3 | public final int getPriority() | 返回线程的优先级
4 | public final void setPriority(String name) | 设定线程名称
5 | public final boolean isAlive() | 判断线程是否在活动，如果是，返回true，否则返回false
6 | public final void join() | 调用该方法的线程强制执行，其他线程处于阻塞状态，该线程执行完毕后，其他线程再执行
7 | public static void sleep(long mills) | 使用当前正在执行的线程休眠mills秒，线程处于阻塞状态
8 | public static void yield() | 当前正在执行的线程暂停一次，允许其他线程执行，不阻塞，线程进入就绪状态；如果没有其他等待执行的线程，这个时候当前线程就会马上恢复执行。
9 | public final void stop() | 强迫线程停止执行，已过时。不推荐使用

```java
package com.lele.multithread;

/**
 * @author: lele
 * @date: 2021/6/29 6:57
 * @description:
 *
 * 介绍线程类的Api方法
 */
public class ThreadApiDemo implements Runnable {

    public static void main(String[] args) {
        // 获取当前线程类的对象
        Thread thread = Thread.currentThread();
        // 获取当前线程的名称
        System.out.println(thread.getName());
        // 获取线程的id
        System.out.println(thread.getId());
        // 获取线程的优先级,在一般系统中范围是0-10的值，如果没有经过设置的话，就是默认值5，有些系统是0-100
        System.out.println(thread.getPriority());
        // 设置线程池的优先级
        /**
         * 优先级越高(数值大）一定越先执行嘛？不是，只是优先执行的概率比较大而已
         */
        thread.setPriority(10);
        System.out.println(thread.getPriority());

        ThreadApiDemo threadApiDemo = new ThreadApiDemo();
        Thread t1 = new Thread(threadApiDemo);
        System.out.println(t1.isAlive());
        t1.start();
        System.out.println(t1.isAlive());
        System.out.println(t1.getPriority());
        System.out.println(t1.isAlive());

//        for(int i = 0; i < 5; i++) {
//            System.out.println(Thread.currentThread().getName() + "--------" +i);
//        }
    }

    @Override
    public void run() {
//        for(int i = 0; i < 5; i++) {
//            System.out.println(Thread.currentThread().getName() + "--------" +i);
//        }
    }
}
```

- 注意：
  - 在多线程的时候，可以实现唤醒和等待的过程，但是唤醒和等待操作对应的不是thread，而是我们设置的共享对象或者共享变量；

**阻塞状态（sleep/yield/join方法）**
- 有三种方法可以暂停Thread执行
  - sleep:不会释放锁，Sleep时别的线程也不可以访问锁定对象；
  - yield：让出CPU的使用权，从运行态直接进入就绪态。让CPU重新挑选哪一个线程进入运行状态。
  - join：当某个线程等待另一个线程执行结束后，才继续执行时，使调用该方法的线程在此之前执行完毕，也就是等待调用该方法的线程执行完毕后再往下继续执行。

### 2. 线程同步

  ![多线程与高并发：线程的同步与死锁](./pics/多线程与高并发：线程的同步与死锁.png)

**使用同步解决线程的安全性问题**
- 同步的前提：
  - 必须有两个或两个以上的线程；
  - 必须是多个线程使用同一资源；
  - 必须保证同步中只能有一个线程在运行；

**解决多线程安全性问题的方法**
- 同步代码块

```java
package com.lele.multithread.ticket;

/**
 * @author: lele
 * @date: 2021/7/3 7:13
 * @description:
 *
 * 多线程并发访问的时候会出现数据安全问题：
 *      解决方式：
 *          1、同步代码块
 *              synchronize（共享资源、共享对象，需要是Object的子类）{具体执行的代码块}
 */
public class TicketRunnable2 implements Runnable {

    private int ticket = 5;

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            synchronized (this) {
                if (ticket > 0) {
                    System.out.println(Thread.currentThread().getName()+"正在出售第"+(ticket--)+"张票");
                }
            }
        }
    }

    public static void main(String[] args) {
        TicketRunnable2 ticket = new TicketRunnable2();
        Thread t1 = new Thread(ticket, "A");
        Thread t2 = new Thread(ticket, "B");
        Thread t3 = new Thread(ticket, "C");
        Thread t4 = new Thread(ticket, "D");

        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
```

- 同步方法

```java
package com.lele.multithread.ticket;

/**
 * @author: lele
 * @date: 2021/7/3 7:13
 * @description:
 *
 * 多线程并发访问的时候会出现数据安全问题：
 *      解决方式：
 *          1、同步代码块
 *              synchronize（共享资源、共享对象，需要是Object的子类）{具体执行的代码块}
 *          2、同步方法
 *              将核心的代码逻辑定义成一个方法，使用synchronize关键字进行修饰，此时不需要指定共享对象
 *
 */
public class TicketRunnable3 implements Runnable {

    private int ticket = 5;

    public static void main(String[] args) {
        TicketRunnable3 ticket = new TicketRunnable3();
        Thread t1 = new Thread(ticket, "A");
        Thread t2 = new Thread(ticket, "B");
        Thread t3 = new Thread(ticket, "C");
        Thread t4 = new Thread(ticket, "D");

        t1.start();
        t2.start();
        t3.start();
        t4.start();

    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            this.sale();
        }
    }

    /**
     * 使用同步方法解决多线程数据安全的问题
     */
    public synchronized void sale() {

//        synchronized (this) {
            if (ticket > 0) {
                System.out.println(Thread.currentThread().getName()+"正在出售第"+(ticket--)+"张票");
            }
//        }
    }
}
```

**线程同步小结**
- 同步监视器
  - synchronized(obj){}中的obj称为同步监视器；
  - 同步代码块中同步监视器可以是任何对象，但是推荐使用共享资源作为同步监视器；
  - 同步方法中无需指定同步监视器，因为同步方法的监视器是this，也就是对象本身；
- 同步监视器的执行过程
  - 第一个线程访问，锁定同步监视器，执行其中代码；
  - 第二个线程访问，发现同步监视器被锁定，无法访问；
  - 第一个线程访问完毕，解锁同步监视器；
  - 第二个线程访问，发现同步监视器未锁，锁定并访问；

#### 2.1 死锁

![多线程与高并发：死锁](./pics/多线程与高并发：死锁.png)

- 同步可以保证资源共享操作的正确性，但是过多同步也会产生死锁；
- 死锁一般情况下表示互相等待，是程序运行时出现的一种问题；

**线程的生产者与消费者**

![多线程与高并发：线程的生产者与消费者](./pics/多线程与高并发：线程的生产者与消费者.png)

- Goods
  ```java
  package com.lele.pc4;

  /**
   * @author: lele
   * @date: 2021/7/6 7:10
   * @description:
   */
  public class Goods {

      private String brand;
      private String name;

      public Goods(String brand, String name) {
          this.brand = brand;
          this.name = name;
      }

      public String getBrand() {
          return brand;
      }

      public void setBrand(String brand) {
          this.brand = brand;
      }

      public String getName() {
          return name;
      }

      public void setName(String name) {
          this.name = name;
      }

  }
  ```

- ProducerQueue

  ```java
  package com.lele.pc4;

  import java.util.concurrent.BlockingQueue;

  /**
   * @author: lele
   * @date: 2021/7/9 6:55
   * @description:
   */
  public class ProducerQueue implements Runnable {

      private BlockingQueue<Goods> blockingQueue;

      public ProducerQueue (BlockingQueue blockingQueue) {
          this.blockingQueue = blockingQueue;
      }

      @Override
      public void run() {
          for (int i = 0; i < 10; i++) {
              Goods goods = null;
              if (i%2 == 0) {
                  goods = new Goods("哇哈哈", "矿泉水");
              } else {
                  goods = new Goods("旺仔", "小馒头");
              }
              System.out.println("生产者开始生产商品:"+goods.getBrand()+"--"+goods.getName());
              try {
                  blockingQueue.put(goods);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
  }
  ```

- ConsumerQueue

  ```java
  package com.lele.pc4;

  import java.util.concurrent.BlockingQueue;

  /**
   * @author: lele
   * @date: 2021/7/9 6:57
   * @description:
   */
  public class ConsumerQueue implements Runnable {

      private BlockingQueue<Goods> blockingQueue;

      public ConsumerQueue(BlockingQueue blockingQueue) {
          this.blockingQueue = blockingQueue;
      }

      @Override
      public void run() {
          for (int i = 0; i < 10; i++) {
              try {
                  Goods goods = blockingQueue.take();
                  System.out.println("消费者消费的商品是："+goods.getBrand()+"--"+goods.getName());
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
  }
  ```

- Test

  ```java
  package com.lele.pc4;

  import java.util.concurrent.ArrayBlockingQueue;
  import java.util.concurrent.BlockingQueue;

  /**
   * @author: lele
   * @date: 2021/7/9 7:00
   * @description:
   */
  public class Test {

      public static void main(String[] args) {
          BlockingQueue<Goods> queue = new ArrayBlockingQueue<Goods>(5);
          ProducerQueue producerQueue = new ProducerQueue(queue);
          ConsumerQueue consumerQueue = new ConsumerQueue(queue);
          new Thread(producerQueue).start();
          new Thread(consumerQueue).start();
      }
  }
  ```


### 3. 线程间的通信
#### 3.1 线程间通信的必要性

#### 3.2 线程通信的实现

### 4. 线程池


## JUC同步工具


## 同步容器

## 线程池

## 高频面试加分项

## Disruptor
